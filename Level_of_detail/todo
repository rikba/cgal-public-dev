
TODO AND OTHER:

// Iteration 1:
1. Redo selector class using property maps.
2. For now I use built in conditions inside selection strategy classes. Change it to any custom condition later.
3. Refactor the preprocessor class.
4. Update Level_of_detail_loader.h - currently it is fixed temporary implementation.
5. For LOD I can stick to my own simple data structures. For some packages like 2D structuring I can already mimic CGAL general style. In general, first make it work with simple data structures and then fix API.
6. It is important to gradually increase the complexity of the input data set and see if our package handles it well.
7. It is maybe helpful to work building by building and create an oriented bounding box around each building, which can become the building's boundary in the worst case.
8. Too long walls come from shape detection package if the cluster_epsilon parameter is choosen to be too large.
9. Some walls are missing due to the precision problems when creating segments (projection of a point onto a line).
10. Buildings with not xy aligned walls sometimes have wrongly rotated segments because the bounding box solutuon that I use to cut lines into segments does not take into account the rotation of the segment.
11. I reject all planes that have an angle more than 10 degrees with respect to the closest vertical plane. This allows to solve some of the missclassification problems.
12. Add a class that will remove artifacts from the given data. E.g. points that become a part of the vertical plane found by RANSAC but in reality belong to another building and/or too far away from the given plane.
13. Should I enforce the same normals for the regularized plane?
14. Add all non-planar points obtained by RANSAC in the clutter selection procedure.
15. Improve the function for getting corners. Use a function to detect all cycles in the undirected graph obtained in the function create_structured_adjacency().
16. Method for adjacency / corners is not robust when wrong planes are detected by the RANSAC. In this case, it may happen that lines that we intersect to get corners produce points which are far away from the real data set.
17. Maybe better to pass all indices except for building boundaries to the visibility class instead of the whole input container?
18. End points of the segments for sparse data sets create wrong visibility labels. E.g. outside triangles are labels inside, because these end points lie a bit further than end points of strucuted segments, which are shifted by LP/2 inside.
19. Intersected segments cannot be used as input to CDT so we have to handle this issue in some way.
20. Add one more label to the input: 1 detected as planar, 0 detected as something else. Then add a selector class to selecte points, which are detected as something else and are facade points that is building boundary. Add these points to the final structured set of points with the label CLUTTER.
21. Actuually my reconstruction code should compute the cost function for each surface S in all graph cut iterations.


// Iteration 2:
1. What about creating new semantic data structures such as "Building", "Tree", "Car" and so on?
2. Can I make an existing edge constrained? What if I have one building inside another one. How can I detect/correct after the graph cut that interior building's walls should be constrained?
3. How to get an edge if I know face handle and its neighbouring face handle?
4. Maybe remove CDT from height fitters?
5. Add a new outliner algorithm that will work with multiple boundaries - for example one exterior boundary and one interior boundary.
6. How to get the n-th face iterator: like std::distance(faces.begin(), n)?
7. How to get indices of the faces, vertices from the iterators when saving them in .ply or any other format?
8. Is it possible to add colors to faces in the Polyhedron_incremental_builder class?
9. How to create a 2-manifold or watertight mesh from the polygonal soup, which is LOD1 now?
10. Add classification labels to Level_of_detail_enum.h.
11. Some buildings turn out to be just a triangle that is why some walls of the buildings have different colours.


// Iteration 3:
