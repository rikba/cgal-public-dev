1. Get access to neighboring faces for each edge. Is edge boundary? - Iterate over finite edges and check if the neighbouring face is infinite or not. If it is then the edge is boundary. Each edge is the pair, where pair.first is the index from which the edge is constructed and pair.second is neighbouring face handle. Using this you can get access to the both faces. So all edges are stored implicitely.
2. What if linear - linear coherence is in between two different buildings? - In this case, you also need to check if the edge is constrained or not.
3. I use the simplest version of Kolmogorov without boost. - Yes, use graph.h.
4. Separate buildings: how to get indices? - Use the following pseudo code (input after graph cut with visibility information): 

Set all face tags to -1
Iterate over all faces
	If the face tag is -1 and IN then call the function flood(face_handle)
In the function flood check if the edge (for all three edges) is constrained, between inside and outside, or between inside and inside, tag the corresponding faces.
At the end you should have all triangles which are 0, 1, 2 and so on buildings.
Next you need to build the connectivity between building's walls so that I could traverse from the vertex with index 0 counterclockwise to the vertex with index n - 1, and then 0 again. - To do this, consider all linear and corner vertices as corner vertices and then start from one inside triangle and follow the wedge with all neighbouring triangles until you hit the constrained edge, then go to the next angle and do the same. While doing so, also save for each traversed triangle for each corner what wedge it belongs to. Instead of wedges I can also use std::map<Corner> instead.

5. Extrusion: 3D Delaunay triangulation? What if I have only 4 points? - Use CGAL_incremental_builder from Polyhedral_surface or Surface_mesh. Save all in ply format with random colour for each building. Building's walls store as quadrilaterals, ground as triangles and roof as triangles. Build connectivity based on the indices of the building's vertices. Simply insert a vertex and then a face. If it is not manifold or not oriented then it can bug, while the ply format will load it as the polygonal soup. Non manifold means that the same vertex is shared by two buildings for example. Random colour can be generated by picking three random values for rgb.